module python.c;

@trusted @nogc nothrow:

#define PY_SSIZE_T_CLEAN
#include <Python.h>
#include <structmember.h> // PyMemberDef
#include <datetime.h>

// FIXME: The two macros below aren't showing up for some reason
enum TypeFlags {
    BaseType = Py_TPFLAGS_BASETYPE,
    Default = Py_TPFLAGS_DEFAULT,
}

// Demacroify
// Used to declare custom Python objects, needs to be mixed in at the
// top of the struct.
mixin template PyObjectHead() {
    PyObject_HEAD;
}

// Hand-translate PyObject_HEAD_INIT since the C code in the macro isn't
// valid D code to initialise a struct with.
auto pyObjectHeadInit(T)(T type) {
    return PyObject(1, type);
}


// Hand-translate PyModuleDef_HEAD_INIT since the C code in the macro isn't
// valid D code to initialise a struct with.
auto pyModuleDefHeadInit() {
    return PyModuleDef_Base(
        pyObjectHeadInit(null),
        null, /* m_init */
        0,    /* m_index */
        null, /* m_copy */
    );
}

auto pyTrue() {
    // FIXME:
    // This doesn't work as a manifest constant because there's a cast that the CTFE
    // engine doesn't like
    //return Py_True;
    // TODO: use Py_True instead, but it's apparently broken on windows
    return PyBool_FromLong(1);
}

// Demacroify
auto pyFalse() {
    // FIXME:
    // This doesn't work as a manifest constant because there's a cast that the CTFE
    // engine doesn't like
    //return Py_False;
    // TODO: use Py_False instead, but it's apparently broken on windows
    return PyBool_FromLong(0);
}

auto pyObjectNew(T)(PyTypeObject* typeobj) {
    return cast(T*) _PyObject_New(typeobj);
}

// Demacroify
// FIXME:
// This fails due to some weird is(typeof) check for the date time capsule
void pyDateTimeImport() @nogc nothrow {
    PyDateTime_IMPORT;
}

// static inline function in the header
static int PyType_HasFeature(PyTypeObject *type, ulong feature) @safe @nogc pure nothrow {
    ulong flags;
    flags = type.tp_flags;
    return (flags & feature) != 0;
}

// static inline function in the header
static int _Py_IS_TYPE(const PyObject *ob, const PyTypeObject *type) @safe @nogc pure nothrow {
    return ob.ob_type == type;
}

// the check is here since this doesn't exist in Python 3.8
static if(is(typeof(Py_IS_TYPE(null, null)))) {
    // copied from 3.10 object.h
    private int _PyObject_TypeCheck(PyObject *ob, PyTypeObject *type) @trusted nothrow {
        return Py_IS_TYPE(ob, type) || PyType_IsSubtype(( ( cast( PyObject * ) ( ob ) ) . ob_type ), type);
    }
}
